# express

#### introduction

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */

1) express              // 生态圈相较完整

    npm i express

2) koa2                 // 接口更丰富，友好

3) ...


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * http module
 * 
 * 
 * 1) 根据不同的请求路径，请求方法，做不同的事情，处理起来比较麻烦
 * 2) 读取请求体和写入响应体是通过流的方式，比较麻烦
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### express basic

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 配置请求映射，根绝不同的请求( 若请求方法和路径均满足后 )，匹配不同的处理函数
 *
 *
 * const app = express();
 * app.method(path, fn);
 */

/**
 * REST STYLE API
 *
 *
 * /api/test    post        根据不同方法执行不同的请求
 *              get
 *              put
 *              delete
 *              ...
 *
 *              all                     匹配所有方法
 *
 *              all('*', ()=>{});       匹配所有路径
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### nodemon

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * nodemon              // 监听文件变化， 当文件内容发生改变时自动更新并重新执行文件
 *
 *
 * npm i -D nodemon
 *
 ** 利用 nodemon.json 扩展细节配置
 */

npx nodemo index.js

// package.json

"scripts": {
    "start": "nodemon --x npm run server",
    "server": "node index"
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### express middleware

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * app.method(path, (req,res,next)=>{} ...);
 *
 * @ (req,res,next)=>{}
 *      - request: 请求
 *      - response: 响应
 *      - next: 手动触发，将当前中间件的结果递交给下一个中间件
 *
 ** 1) 匹配 path
 *
 *      a) 匹配成功
 *
 *          依次交给中间件处理( 中间件中需要手动调用 next(); 后才可以递交给后续中间件处理 )
 *
 *      b) 中间件细节
 *
 *          若递交后，已无后续中间件( express 发现响应无结果，则会响应 404 )
 *
 *      c) 匹配失败
 *
 *          不会停止服务器
 *          相当于调用 next(errObj);
 *          寻找后续错误处理中间件( 若无错误处理中间件，则响应 status: 500 )
 */

                  Request
                     |
        + ------------------------- +
        |                           |
        |    exprress_middleware    | --->  response
        |                           |
        + ------------------------- +
                     |
                    \|/
        + ------------------------- +
        |                           |
        |    exprress_middleware    | --->  response
        |                           |
        + ------------------------- +
                     |
                    \|/
        + ------------------------- +
        |                           |
        |         ... ...           |
        |                           |
        + ------------------------- +
                     |


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### express inner middleware

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * express.static();
 * 
 * 
 * 自动响应并返回 静态资源
 * 
 ** 默认情况: 若 staticPath 为目录，则读取 index.html 作为索引文件
 */

// 当请求时，根据请求路径，从指定的目录中寻找是否存在该文件

    1) 存在: 直接响应文件，不再交给后续的中间件处理
    
    2) 不存在: 直接移交给后续中间件处理( 调用 next(); )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * express.urlencoded(options);
 * 
 * 
 * 用于解析 'application/x-www-form-urlencoded' 格式的消息体
 */


需要开启

options: {

    extended: true,             // 支持更丰富的编码形式
}


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * express.json();
 * 
 * 
 * 用于解析 'json' 格式的消息体
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### express-cookie

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * cookie middleware
 * 
 * 
 * 
 */

npm i cookie-parser


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/** 理论上 **/

// 假设服务器有一个接口，通过请求该接口，可以添加一个管理员
// 但不是任何人都有权力做这种操作
// 服务器是如何知道请求接口的人的权力的呢？

答案: 只有登陆过的管理员才有权力执行该操作


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 问题: 客户端与服务器的传输使用的是 "http/https 协议( 该协议无状态 )"
//      服务器无法判断这次请求和之前请求成功的人是否为同一个人

由于 http/https 协议无状态，服务器无法判断当前请求和之前请求的客户端是否为同一个客户端


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 解决 http/https 协议无状态

1) 客户端登陆成功后，服务器会给客户端一个 "出入证"

2) 后续客户端的每次请求，都必须要附带这个 "出入证"


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// cookie 的产生

用户登陆不同的网站，还会收到服务器给予的多个 "出入证"，因此客户端需要一个类似卡包的东西:

1) 能够存放多个出入证: 

    可能来自多个网站
    也可能是一个网站中的多个出入证

2) 能够自动出示出入证:

    当客户端访问不同网站时，能自动吧对应的出入证附带请求发送出去

3) 正确的出示出入证:

    客户端不能将肯德基的出入证发送给麦当劳

4) 管理出入证的有效期:

    客户端能够检查已过期的出入证，并从卡包中移除


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// cookie 的组成

key         // 键

value       // 值

domain      // 域名

path        // 域名下的路径

secure      // 是否安全传输

expire      // 过期时间


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 当 cookie 同时满足以下条件时，则会被附带到请求中

1) cookie 未过期

2) cookie.domain === requset.domain;            // 域名一致即可，忽略端口

3) cookie.path === request.path;                // 可匹配当前 path 及 以 /path/... 为根路径的后代路径

4) cookie.secure === true ? https : http;       // 是否开启安全传输


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 如何设置 cookie
 * 
 * 
 * 由于 cookie 是保存在浏览器端，同时很多证件又是服务器端颁发的
 */


// 服务器响应

当服务器哥诶客户端颁发一个证件时，会在响应消息中包含 cookie，浏览器会自动的吧 cookie 保存到卡包中


// 客户端自行设置

该情况较少，(例如: 用户关闭某个广告，并选择"以后不再弹出") 该种情况会通过浏览器的JS代码保存到 cookie 中
后续请求服务器时，服务器会看到客户端不想再次弹出广告的 cookie，则不会再发送广告过来


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 服务器端设置 cookie
 * 
 * 
 * 服务器端可通过设置响应头，来设置浏览器中的 cookie
 * 
 ** 浏览器会自动将 cookie 保存到卡包中，若卡包中已存在 "相同卡片( key, path, domain 相同 )"，则自动覆盖该卡片之前的配置
 */


// 可根据需求，在一次响应中设置多个 cookie

set-cookie: cookie_01
set-cookie: cookie_02
set-cookie: cookie_03
... ...


// cookie 格式如下( key=val 是必须设置的，其他属性为可选属性，并且顺序不限 )

key=val; ?path=''; ?domain=''; ?expire=''; ?max-age=''; secure=''; ?httponly='';


/** 必填配置 **/

key=val;


/** 可选配置 **/

path:               // 默认当前请求中的 路径

domain:             // 默认当前请求中的 域名

// 回话结束后过期: 对于即没有设置 expire & max-age 的请求

expire:             // 设置 cookie 的过期时间( 必须为有效的 GMT 时间 )，当到达过期时间，客户端会自动销毁该 卡片

max-age:            // 设置 cookie 的相对有效期( expire & max-age 仅设置一个即可 )
                    // eg: max-age: 1000; 则 cookie 到期时间为 expire + 1000 为最终到期时间

secure:             // 设置 cookie 是否是安全链接
                    // 若设置该值，则表示该 cookie 后续只能随着 https 请求发送
                    // 若不设置，则表示 cookie 会随着所有请求发送

httponly:           // 设置 httponly 是否技能用于传输
                    // 若设置该值，表示该 cookie 仅能用于传输，而不允许在客户端通过 JS 截获，防止跨站脚本攻击( XSS )


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 客户端设置 cookie
 * 
 * 
 ** 若设置了 httponly，则无法通过 document.cookie 设置 cookie
 ** path&domain默认值: 在客户端设置 coookie 时，也许根本未发生请求，path 在客户端设置时的默认值是当前网页的path
 */


document.cookie = 'key=val; key=val; ?path=''; ?domain=''; ?expire=''; ?max-age=''; secure=''; ?httponly='';'


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


/**
 * 无论是 客户端 还是 服务器，删除 cookie
 * 
 * 
 * 修改过期时间即可
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### 断点调试

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * node --inspect           // 该进程会监听 9229 端口
 * 
 * 
 * 当使用该种方式打开 index 文件时，可在浏览器中打断点调试
 */

node --inspect index


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

### Cross-domain

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 同源策略
 * 
 * 
 * 协议/域名:端口 完全匹配称为 同源
 ** 浏览器不允许使用非同源数据
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### JSONP

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * JSONP
 *
 *
 * 1. 浏览器端生成一个 script 元素，访问数据接口
 * 2. 服务器响应一段JS代码，调用某个函数，并把响应的数据传入
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * JSONP 并不是很好的跨域解决方案
 * 
 * 
 * 存在以下较严重问题等
 */

1) 打乱服务器消息格式: JSONP 要求服务器响应一段JS代码，但在非跨域的情况下，服务器又需要响应一个正常的JSON格式

2) 只能完成GET请求: JSONP的原理会要求浏览器端生成一个script元素，而script元素发出的请求只能是 GET

3) ... ...


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### CORS

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * cors middleware
 * 
 * 
 * 
 */

npm i cors


//-------------------------------------------------------------------------------------------------------------------//


/**
 * Cross Origin Resource Sharing                    // 跨域资源共享
 * 
 * 
 * 
 * CORS 是基于 "http 1.1" 的一种跨域解决方案
 ** 总体思路: 若浏览器要跨域方案服务器的资源，需要获得服务器的允许
 */


//-------------------------------------------------------------------------------------------------------------------//


/**
 * 跨域访问时，JS仅可获取基本的响应头
 * ( eg: Cache-Control, COntent-Language, Content-Type, Expires, Last-Modified, Pragma )
 * 
 * 
 * 若要访问其他请求头，则需要服务器设置本响应头
 */


Access-Control-Expose-Heaers: authorization, a, b...



//-------------------------------------------------------------------------------------------------------------------//


/** 简单请求 **/

当浏览器端运行了一段 ajax 代码( 无论是使用 XMLHttpRequest 还是 fetch api )
浏览器会首先判断它属于哪一种请求模式


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 有且仅当同时满足下列条件时，属于 "简单请求"

1) 请求方法，仅包含下列方法之一

- get
- post
- head

2) 请求头，仅包含下列安全字段之一

- Accept
- Accept-Lauguage
- Content-Lauguage
- Content-Type
- DPR
- Downlink
- Save-Data
- Viewport-Width
- Width

3) 请求头若包含 content-type，仅限下面值之一

- text/plain
- multipart/form-data
- application/x-www-form-urlencoded


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 简单请求的交互规范
// 当浏览器判断某个 ajax 跨域请求为 简单请求 时


在页面 "http://my.com/index.html" 中跨域请求 fetch('http://crossdomain.com/api/news');

 
1) 会在请求头中自动添加 Origin 字段

headers: {
    GET: /api/new/ HTTP/1.1
    Host: crossdomain.com
    Connection: keep-alive
    ...
    Referer htttp://my.com/index.html
    Origin: http://my.com
}


2) 服务器响应头中应包含 Access-Control-Allow-Origin

当服务器收到请求后，若允许该请求跨域访问，需要在响应头中添加 Access-Control-Allow-Origin 字段

Access-Control-Allow-Origin: *                  // 允许任何跨域来源访问
                             http://my.com      // 仅允许指定跨域源访问( 建议使用 )


3) 浏览器收到服务器的响应，将响应结果交给 JS


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// 简单请求
fetch("http://crossdomain.com/api/news");


// 非简单请求: 请求方法不满足
fetch("http://crossdomain.com/api/news", {
    method: "put"
});


// 非简单请求: 加入了额外的请求头
fetch("http://crossdomain.com/api/news", {
    headers: {
        a: 1
    }
});


// 简单请求
fetch("http://crossdoamin.com/api/news", {
    method: "post"
});


// 非简单请求: content-type不满足
fetch("http://crossdoamin.com/api/news", {
    method: "post",
    headers: {
       "content-type": "application/json"
    }
});


//-------------------------------------------------------------------------------------------------------------------//


/** 需要预检的请求 **/

简单请求对服务器威胁不大，所以允许使用上述简单交互即可完成
若浏览器判断该请求不是简单请求，则会判定为 预检请求

1. 浏览器发送预检请求，询问服务器是否允许
2. 服务器允许
3. 浏览器发送真实请求
4. 服务器完成真实请求


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


在页面 "http://my.com/index.html" 中跨域请求

// 需要预检请求
fetch("http://crossdomain.com/api/user", {
    methodL "POST",                                     // post 请求
    headers: {                                          // 设置请求头
        a: 1,
        b: 2,
        "content-type": "applicattion/json"
    },
    body: JSON.stringify({ name: 'alpha', age: 18 }),   // 设置请求体
});

// 浏览器判断该请求为 预检请求


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


1) 浏览器发送预检请求，询问服务器是否允许

OPTIONS /api/user HTTP/1.1
Host: crossdomain.com
...
Origin: http://my.com
Access-Control-Requset-Method: POST
Access-Control-Requset-Headers: a, b, content-type


// 该请求并非真实请求( 请求中不包含响应头，也没有消息体 )
// 该请求目的: 询问服务器，是否允许后续的真实请求

- 请求方法
- 没有请求体
- 请求头中包含
    - Origin:                               // 请求的源，和简单请求的含义一致
    - Access-Control-Request-Method:        // 后续的真实请求将使用的请求方法
    - Access-Control-Request-Headers:       // 后续的真实请求会改动的请求头


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


2) 服务器允许

服务器收到预检请求后，可以检查预检请求中包含的信息，若允许这样的请求，则需要响应下面的消息格式


HTTP/1.1 200 OK
Date: Tue, 21 Apr 2020 8:03:35 GMT
...
Access-Control-Allow-Origin: http://my.com
Access-Control-Allow-Methods: POST
Access-Control-Allow-Headers: a, b, content-type
Access-Control-Max-Age: 86400
...


// 对于预检请求，不需要响应任何的消息体，只需要在响应头中添加以下配置:

Access-Control-Allow-Origin: 和简单请求一样，表示允许的源
Access-Control-Allow-Methods: 表示允许的后续真实请求方法
Access-Control-Allow-Headers: 表示运修改动的请求头
Access-Control-Max-Age: 告知浏览器，多少秒内，对于相同的请求源，方法，头，都不需要再次发送 预检请求


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


3) 浏览器发送真实请求

POST /api/user HTTP/1.1
Host: crossdomain.com
Connection: keep-alive
...
Referer: http://my.com/index.html
Origin: http://my.com

{ "name": "alpha", "age": "18" }


//- -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - -//


4) 服务器响应真实请求

HTTP/1.1 200 OK
Date: Tue, 21 Apr 2020 08:03:35 GMT
...
Access-Control-Allow-Origin: http://my.com
...


添加用户成功


//-------------------------------------------------------------------------------------------------------------------//


/** 附带身份凭证的请求 **/

默认情况下，ajax 的跨域请求并不会附带 cookie，则某些权限的操作就无法进行

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -//


// xhr
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;

// fetch api
fetch(url, {
    credentials: "include"
});


这样以来，该跨域的 ajax 请求就是一个附带身份凭证的请求
当一个请求需要附带 cookie 时，无论它是简单请求，还是预检请求，都会在请求头中添加 cookie 字段
而服务器响应时，需要明确告知客户端: 服务器允许这样的凭据
告知的方式: 在响应头中添加 Access-Control-Allow-Credentials: true
对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝

* 注意: 对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin: *


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

#### session

``` javascript
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/**
 * 
 * 
 * 
 * 
 */


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
```

























